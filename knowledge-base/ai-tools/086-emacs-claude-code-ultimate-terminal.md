# Emacs、Claude Code 與終極終端：認知操作系統的未來

> **來源**: [@blackanger](https://x.com/blackanger/status/1952073655930011974)
>
> **日期**: Sun Aug 03 18:26:42 +0000 2025
>
> **標籤**: `Claude Code` `Emacs 哲學` `認知增強`

---

這篇文章探討了 Emacs 的設計哲學與現代 AI 工具（如 Claude Code）的結合可能性,展望未來「認知操作系統」的願景。

## Emacs 的永恆智慧

### Buffer 哲學:萬物皆畫布

Emacs 的核心理念是「Everything is a buffer」——一切皆緩衝區。這個設計將所有不同類型的資訊統一到同一個抽象概念下。正如計算機科學家 Alan Perlis 所說:「與其有 10 個函數操作 10 種資料結構,不如有 100 個函數操作一種資料結構。」

一個典型例子:在 Emacs 的 Dired 模式中,你可以像編輯文字一樣編輯檔案列表。當需要重新命名檔案時,只需:

1. 按 `C-x C-q` 進入編輯模式
2. 用 `M-$` 對檔案名進行拼寫檢查
3. 選擇正確拼寫
4. `C-c C-c` 提交更改

檔案系統中的檔案名就這樣被修正了。這種「意想不到的協同」正是統一性帶來的魔力。

Buffer 不僅是技術概念,它代表了一種看待資訊的全新方式:資訊不被鎖在不同應用程式的圍牆裡,而是流動的、可組合的、可程式化的。這本質上是在說:工具應該適應人的思維方式,而不是相反。

### Org Mode:簡化的藝術

Org Mode 建立在一個簡單的觀察之上:人類天然地用層次結構來組織思維。我們寫文章用大綱,整理檔案用資料夾,記筆記用縮排。

Org Mode 的天才之處在於,它把所有複雜的操作簡化成了一個按鍵:`TAB`。當你按下 TAB 鍵時,系統會根據上下文智慧地決定是展開內容、收起內容,還是循環切換不同的顯示狀態。這揭示了一個深刻的洞察:**複雜性應該存在於系統內部,而不是使用者介面上**。

更重要的是,TAB 鍵不只是一個功能鍵,它是一個「思維操作符」。當你使用它時,你實際上在進行一種基本的認知操作:在細節和全局之間切換。

這個設計揭示了幾個深刻的道理:

- **層次化是人類認知的基本模式**:我們用大綱組織文章,用目錄組織檔案,用分類組織知識。Org mode 不是在創造新的組織方式,而是在尊重人類既有的思維模式
- **摺疊/展開是通用的資訊管理原語**:當你按下 TAB 時,你在進行一種基本的認知操作:在細節和全局之間切換。這不僅適用於文字,也適用於程式碼、資料、對話歷史——任何資訊
- **介面即思維工具**:TAB 鍵幫助你聚焦(關注細節)、抽象(把握全局)、導航(在結構中移動)

這些洞察對理解「終極終端」至關重要。因為它告訴我們:好的工具不是功能的堆砌,而是對人類認知模式的深刻理解和優雅支援。

## AI 如何改變遊戲規則

### Claude Code 的革命:從命令到對話

Claude Code 的革命性不僅在於 AI 能力,更在於它重新定義了什麼是「人機互動」。

**Claude Code 的運作本質:**

```
使用者意圖(自然語言)
    ↓
Claude 理解並生成程式碼
    ↓
在上下文環境中執行
    ↓
結果回饋到對話流
    ↓
狀態持續更新
```

傳統的命令列要求你學習精確的語法和命令,但 Claude Code 讓你可以用自然語言來表達意圖:「幫我分析這個效能問題」、「重構這段程式碼,讓它更易讀」、「解釋這個錯誤訊息」。

更深層的革命在於**上下文的持續性**。觀察一個典型的 Claude Code 會話,你會發現對話自然地形成了層次結構:你提出一個問題,Claude 給出回答,你要求深入某個方面,Claude 進一步展開,你詢問具體細節,Claude 提供詳細解釋。這種結構不是預先設計的,而是自然湧現的,因為它符合人類探索和理解問題的方式。

當我們把 Emacs 的 Buffer 哲學和 Claude Code 的對話模式放在一起看時,會發現一個驚人的共鳴:**它們都在追求認知的統一性**。

- Emacs 通過 Buffer 統一了不同類型的資訊,讓你可以用相同的方式操作文字、程式碼、檔案列表
- Claude Code 通過自然語言統一了不同類型的任務,讓你可以用對話的方式完成程式設計、分析、學習

兩者的核心理念是一致的:**消除人與資訊之間的障礙,讓操作變得自然而直觀**。

更有趣的是,如果我們仔細觀察,會發現 Claude Code 的對話歷史本質上就是一個「buffer」——它記錄了所有的互動,保持了完整的上下文,可以被引用、被修改、被擴展。而 Emacs 的操作方式,如果用自然語言來表達,不就是一種對話嗎?「找到所有包含這個詞的地方」、「把這段文字移到那裡」、「記住這個位置」。

這種共鳴暗示著一個可能性:也許 Emacs 和 Claude Code 不是兩個獨立的工具,而是同一個理念在不同時代的表現形式。

然而,目前 Claude Code 介面並沒有充分利用 Emacs 的 Org-mode 模式。

想像一下,如果 Claude Code 能像 Org mode 那樣:

- 用 TAB 鍵摺疊/展開對話的不同部分
- 只顯示關鍵決策點,隱藏冗長的解釋
- 在不同的抽象層次上回顧對話歷史

這也許能再一次改變我們與 AI 互動的方式。

### 從「工具思維」到「環境思維」

Emacs 社群有句老話:「Emacs 不是一個編輯器,而是一個偽裝成編輯器的 Lisp 解釋器。」

類似地,我們可以說:「**Claude Code 不是一個 AI 助手,而是一個偽裝成助手的認知作業系統**。」

這種思維轉變意味著什麼?

**在傳統工具思維下:**

你打開 IDE 寫程式碼 → 切換到終端執行命令 → 打開瀏覽器查文件 → 使用另一個工具發送郵件

**在 Emacs 的環境思維下:**

你在一個統一的環境中工作 → 用 `M-x compile` 編譯,錯誤訊息可以直接跳轉到原始碼位置 → 用 `eww` 瀏覽網頁,內容可以直接複製到程式碼中 → 用 `message-mode` 寫郵件,可以直接引用程式碼片段

**在 Claude Code + 其 SDK 的未來願景下:**

你用自然語言描述意圖 → AI 理解上下文並執行多步驟操作 → 所有中間結果都在統一的認知空間中流轉 → 你可以隨時介入、修改、引導過程

### 學習曲線從陡峭到平緩的演化

程式設計師社群討論中有個有趣的觀點:Vim 和 Emacs 都有陡峭的學習曲線,「所以,你不能只是試試水,必須一頭扎進去。」這句話對 Rust 語言同樣適用。

但是,現在也有 Spacemacs、Doom Emacs 這樣的發行版,新手可以獲得開箱即用的現代體驗。而 Claude Code 則更進一步——它用自然語言互動降低了入門門檻。

這裡有個深刻的轉變:

- **Emacs 時代**:你需要學習 Elisp 來定製你的環境
- **Claude Code 時代**:你用自然語言描述你想要什麼

但核心理念是一致的:**給使用者完全的控制權,讓他們能夠塑造自己的數位環境**。

## 終極終端幻想:Emacs + AI

想像一下,如果我們將 Emacs 的哲學與 Claude 的 AI 能力真正融合,會創造出什麼樣的工具?

我稱之為**認知作業系統**——一個真正理解你的思維方式並能無縫支援你的工作環境。

在這個環境中,自然語言和傳統命令不是對立的,而是互補的。你可以用自然語言描述高層次的意圖:「幫我重構這個模組,讓它更符合單一職責原則」,系統會理解並執行;你也可以用精確的命令進行細粒度的控制,就像現在的 Emacs 一樣。關鍵是,系統理解這兩種輸入方式之間的關係,能夠在它們之間無縫切換。

更重要的是**層次化的支援**。就像 Org Mode 用 TAB 鍵優雅地處理資訊的層次,未來的系統應該能夠智慧地管理對話和操作的層次。你可以「摺疊」一段對話,只保留核心結論;可以「展開」一個操作,查看詳細的執行過程;可以在不同的抽象層次上查看和理解你的工作。

### Emacs + AI 可能帶來的體驗

**智慧搜尋與編輯:**

你告訴 Claude:「找出所有呼叫 deprecated API 的地方」。Claude 不僅搜尋程式碼,還理解語意,將結果展示在一個 occur-mode 風格的 buffer 中。

**上下文感知的批次修改:**

在搜尋結果 buffer 中,你可以像使用 `wgrep`(在搜尋結果中直接批次修改)一樣直接編輯,但 Claude 會智慧地理解每處修改的上下文,自動調整相關的 use 陳述式、型別定義等。

**多模態工作流:**

你在 org-mode 中記錄重構計畫,其中嵌入了程式碼區塊。Claude 可以理解這些程式碼區塊與實際專案程式碼的關係,幫你追蹤進度、驗證改動。

**時間機器:**

就像 Emacs 的 `undo-tree` 可以視覺化編輯歷史,未來的 AI 終端可以展示你的「認知歷史」——不僅是文字改動,還包括你的決策過程、棄用的方案、探索的路徑。

在這個環境中:

- 每一層都可以摺疊/展開,讓你在細節和全局間自由切換
- 所有內容都是活的:程式碼可以執行,分析可以更新,對話可以繼續
- AI 理解整個上下文:不是孤立的對話,而是完整的研究過程
- 知識是結構化的:可以匯出、分享、複用

這種 Emacs + AI 的融合不僅僅是技術上的進步,更可能改變我們與電腦互動的根本方式。

對個人而言,它意味著真正的「認知增強」。不是 AI 替代你思考,而是 AI 成為你思維的延伸。就像眼鏡增強了視力,這種工具增強的是你組織、理解和創造資訊的能力。你不需要記住複雜的命令,但也不會失去精確控制的能力;你可以快速完成常規任務,但也能深入探索複雜問題。

## 尾聲

回到開始的問題:Emacs + AI 是否是終極終端?

我的答案是:它們代表了終極終端的兩個關鍵要素——**統一的操作環境和自然的互動方式**。真正的終極終端不是簡單地把它們加在一起,而是深度融合它們的設計理念,創造出真正的認知作業系統。

然而,我其實並不是真的希望 Emacs 與 AI 融合。因為現在的我依然對使用 Emacs 來心有餘悸。

我真正希望的是 **Emacs 理念 + AI 的融合之後的更易用的 Claude Code**。

終極終端不是一個具體的工具,而是一種理念的實現——讓每個人都能夠自由地塑造自己的數位認知空間,無論是通過程式碼、自然語言,還是我們尚未想像到的互動方式。

正如前文中講到修正檔案名拼寫的那個範例所展示的——真正的力量不在於某個特定功能,而在於當你需要時,系統能夠以你意想不到的方式組合已有能力,優雅地解決問題。

這就是我們追求的:

- 不是更多的功能,而是更深的可組合性
- 不是更智慧的工具,而是更懂你的環境
- 不是 AI 替代人類,而是 AI 成為人類認知的自然延伸

Emacs 的哲學與 Claude 的 AI 能力不是相互替代,而是相互成就。它們共同指向一個未來:每個人都是自己數位宇宙的創造者,而終端,只是通向這個宇宙的第一扇門。

## 延伸思考:碎片宇宙與個體創造

### 從造輪子到創造宇宙

專業程式設計師,在 Vibe Coding 加持下,會把他們造輪子的習慣發揮到極致。將來每個有能力駕馭 vibe coding 的人,會擁有自己的獨立創意宇宙。

很多人將「造輪子」視為資源浪費,但實際上,造輪子本身是一種創作衝動,而非實用主義行為。造輪子是他們對工具的「個性化索取」,甚至是藝術創作。

而 Vibe Coding 使個體進入高度沉浸狀態,獲得了「創造的直覺」與「即時回饋的快感」。

一旦脫離企業生產邏輯,進入「自己為自己寫程式」的 vibe 狀態,造輪子反而變成了程式設計的常態,是創作的「基本動作」。

隨著 Vibe Coding AI 工具的成熟,這個趨勢將到了極致:

- 人們不再用統一的大平台,而是編織屬於自己的「數位行星系」
- 不再以開源、協作為主導價值,而是傾向於打造屬於自己的封閉小世界
- Vibe Coding 是「技術即創作」的範式轉變,它將程式設計師轉化為「創造者」,而非「解決問題的人」

這個宇宙包含:

- 私有的工具(為自己量身定做)
- 私有的表達形式(文字、影片、AI 代理、模擬世界)
- 私有的生態(執行在獨特範式下的小程式、外掛、腳本、模型等)

這是「程式碼即個性」的體現。你甚至可以說——這些作品不是軟體,而是數位自畫像。

最終,每一個人都可能成為一個「數位自治體」的締造者。

### 從封閉到連接

然而,這還將會持續演化。最初,每個「數位自治體宇宙」都是封閉的,就像早期的原始部落。但人類有一個傾向:在孤獨中創造語言,在語言中尋找共識。

所以我們可以想像一個場景:

- 每個 Vibe Coder 造出了自己的 mini 生態系統
- 他們不會主動開源,但可能願意暴露某些介面
- 於是,「宇宙對宇宙」的連接協定開始出現——形成某種「星際協定」,但不再是為了通用性,而是為了「個體意志的低摩擦協同」

這樣的演變是從「平台主導的協作模式」向「個體主導的創造模式」轉變。

Andrej Karpathy 前兩天發推說:

> 2024: everyone releasing their own Chat  
> 2025: everyone releasing their own Code

那 2026 年呢?我想說:

> 2026: everyone releasing their own Toy, Tool, or Terminal.  
> 2030: everyone running their own Universe.

未來不是統一的大一統平台,而是數百萬個精緻、自洽、不可通約的微宇宙。

Vibe Coding,不只是寫程式碼的方式變了,而是人類用程式碼創造身份的範式變了。
