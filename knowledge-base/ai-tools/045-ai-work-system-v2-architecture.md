# 個人 AI 系統升級到第二代：架構全公開

> **來源**: [@Roland_WayneOZ](https://x.com/Roland_WayneOZ/status/2022850233861075105)
>
> **日期**: 2026-02-15
>
> **標籤**: `Claude Code` `AI系統` `記憶架構` `TELOS` `自我迭代` `工作流`

---

## 百萬閱讀之後，我發現了一個問題

不久前我發了一篇《如何用 Claude Code 在 3 分鐘搭建一套可迭代的永續 AI 工作系統》。收穫將近百萬閱讀。很多人照著做了。

但我收到最多的反饋是：

- "系統搭好了，然後呢？"
- "AI 還是不記得上次聊了什麼。"
- "文件越來越多，越來越亂。"
- "我還是要自己維護這個系統。"

這些問題我自己也遇到了。

第一代系統有個根本問題：它是靜態的。

你搭建了一個框架，但框架不會自己變好。你往裡面扔東西，但東西不會自己整理。你教 AI 認識你，但 AI 不會自己學習。

這不是真正的「永續」。

真正的永續系統應該是：你用它，它就在進化。

所以我花了一個星期，把系統升級到了第二代。

核心變化一句話：第一代你維護系統，第二代系統維護自己。

## 第一代 vs 第二代：6 個核心差異

### 差異 1：記憶結構

第一代：記憶庫是一個資料夾，你往裡面扔東西。

第二代：三層記憶架構。

假設你和 AI 討論了「如何寫爆款標題」。

第一代的做法：
```
記憶庫/
└── 2026-02-13-爆款標題討論.md
```
扔進去，以後大概率找不到。

第二代的做法：
```
記憶庫/
├── 情景記憶/（這次對話的完整過程）
├── 語義記憶/（提煉出的通用規律，可復用）
└── 強制規則/（必須遵守的行為約束）
```

情景記憶讓你能回溯「當時怎麼想的」。語義記憶讓知識可以復用，不用每次重新討論。強制規則讓 AI 不會重複犯同樣的錯。

沒有這個結構，記憶就是一堆文件。有了這個結構，記憶變成可檢索、可復用、可進化的知識資產。

### 差異 2：迭代方式

第一代：你發現問題 → 你決定改 → 你去改。

第二代：AI 發現問題 → AI 提出方案 → AI 執行改動 → AI 驗證結果。

你發現「每次讓 AI 寫文章，它都忘記加封面圖」。

第一代的做法：
- 你發現這個問題
- 你想起來要改 CLAUDE.md
- 你手動加一條規則
- 下次可能還是忘，因為你忘了寫進去

第二代的做法：
- AI 執行八步迭代流程
- 觀察 → 分析 → 設計 → 實施 → 驗證 → 記錄 → 提煉 → 提交
- 自動更新規則，自動驗證，自動記錄

第一代你是系統的維護者，系統不會自己變好。第二代 AI 是系統的維護者，系統會自己進化。

### 差異 3：文件存儲

第一代：你決定文件放哪裡。

第二代：AI 自動決定文件放哪裡。

你說：「幫我寫一篇關於 OpenClaw 的文章。」

第一代的做法：
- AI 寫完
- 問你：「保存到哪裡？」
- 你說路徑
- AI 保存

第二代的做法：
- AI 寫完
- AI 自動識別：這是「文章」類型
- AI 自動查詢存儲規則
- AI 自動保存到正確位置
- AI 告訴你：「已保存到 xxx，內容類型：文章」

第一代你要記住所有分類規則，每次都要思考。第二代 AI 記住規則，你不用思考。減少決策疲勞，保證文件永遠在正確的位置。

### 差異 4：任務追蹤

第一代：沒有。

第二代：時間意圖自動捕獲。

你說：「這篇文章明天發。」

第一代的做法：
- AI 說：「好的。」
- 明天你忘了
- 文章沒發

第二代的做法：
- AI 識別到「明天」這個時間意圖
- AI 自動添加到任務清單
- AI 說：「已添加到任務清單，明天簡報會提醒你。」
- 第二天晨間簡報：「今日待辦：發佈留學文章」

第一代你說的話會丟失，AI 不會主動提醒。第二代你說的每一個時間意圖都會被捕獲，不會遺漏。

### 差異 5：上下文管理

第一代：沒有。

第二代：指令遵循度檢測 + 懶加載。

你和 AI 聊了很久，上下文快滿了。

第一代的做法：
- AI 開始「忘記」早期的指令
- 你發現 AI 行為變奇怪了
- 你不知道為什麼
- 你重新開一個會話，從頭解釋

第二代的做法：
- AI 每次回復都帶「✓」符號
- 當上下文超過 40%，AI 提醒：「建議重開會話」
- 如果 AI 回復沒有「✓」，你知道指令遵循度下降了

第一代你不知道 AI 什麼時候開始「變笨」。第二代你有明確的信號知道什麼時候該重開會話。

### 差異 6：身份系統

第一代：個人定位.md（一個文件寫所有）。

第二代：TELOS 模組化（7 個文件，按需加載）。

第一代：
```
個人定位.md
（所有資訊塞在一個文件裡，AI 每次都要讀完）
```

第二代：
```
本體畫像/
├── 00-核心身份.md      # 必讀
├── 01-價值觀與原則.md   # 按需
├── 02-背景與經歷.md     # 按需
├── 03-技能與能力.md     # 按需
├── 05-目標與規劃.md     # 按需
├── 07-工作方式.md       # 按需
└── 08-關係網絡.md       # 按需
```

第一代 AI 每次都要讀完所有資訊，浪費 token。第二代 AI 只讀需要的模組，節省 token，回應更快。

## 25 個系統級優化方法（完整版）

### 第一類：Token 消耗優化（3個）

**優化方法 1：懶加載策略**

問題：第一代系統啟動時自動讀取所有文件，99%+ 的 token 消耗在 Input 上。

解決方案：只在用戶明確需要時才讀取文件。

規則：
- 不要自動讀取日記、本體畫像目錄、user.md、AI_state.json
- 只在用戶明確需要時才讀取相關文件
- 優先使用已有的上下文資訊
- 如果需要讀取，使用 limit 參數限制行數

**優化方法 2：模組化身份系統（TELOS）**

問題：第一代的個人定位.md 把所有資訊塞在一個文件裡。

解決方案：拆分成 7 個模組文件，按需加載。

加載規則：
- 00-核心身份.md：每次會話必讀（控制在 500 字以內）
- 其他模組：只在相關任務時讀取

效果：只讀核心身份時，token 消耗降低 70%+。

**優化方法 3：漸進式加載（Skill 專用）**

問題：Skill 文件太長，簡單任務也要讀完整個文件。

解決方案：主文件只放觸發詞和核心流程，詳細內容放在 references/ 目錄。

Skill 文件結構：
```
skill.md（主文件，控制在 300 字以內）
├── 觸發詞（必讀，50字）
├── 核心流程（必讀，200字）
└── 參考文件索引（指標，不是內容）

references/（按需讀取）
├── 詳細方法論.md
├── 案例庫.md
└── 參數配置.md
```

### 第二類：上下文管理（3個）

**優化方法 4：指令遵循度檢測**

問題：上下文過載時，AI 會「忘記」早期指令，但用戶不知道。

解決方案：每次回覆帶「✓」符號，作為指令遵循度的標誌。如果回覆沒有「✓」符號，說明上下文已過載，此時應提醒用戶使用 /new 重開會話。

**優化方法 5：上下文使用閾值**

問題：用戶不知道什麼時候該重開會話。

解決方案：當上下文使用超過 40% 時，指令遵循度開始下降；超過 60% 時，必須主動提醒用戶重開會話。

**優化方法 6：會話邊界管理**

問題：單個會話做太多事情，上下文很快過載。

解決方案：複雜任務拆分成多個會話，每個會話聚焦一個主題。

### 第三類：記憶管理（3個）

**優化方法 7：三層記憶架構**

問題：第一代的記憶庫是一個資料夾，扔進去就找不到了。

解決方案：三層架構，從事件到知識到規則。

```
記憶庫/
├── 情景記憶/（具體事件和對話，按月歸檔）
├── 語義記憶/（提煉的知識和模式）
└── 強制規則/（系統行為約束）
```

命名規範：
- 情景記憶：MMDD-簡短描述.md
- 語義記憶：[主題]_[類型].md
- 強制規則：強制規則_[領域].md

**優化方法 8：記憶提煉機制**

問題：情景記憶越來越多，但沒有提煉成可復用的知識。

解決方案：設置提煉觸發條件。

提煉時機：每次自我迭代時、發現重複模式時（≥3次）、完成重大項目後。

流程：情景記憶 → 識別模式 → 語義記憶 → 發現必須遵守的規則 → 強制規則。

**優化方法 9：日記月記合併機制**

問題：日記文件越來越多，檢索成本越來越高。

解決方案：每月初自動合併上個月的日記為月記，合併後刪除原始日記文件。

### 第四類：任務管理（3個）

**優化方法 10：時間意圖自動捕獲**

問題：用戶說「明天發」，AI 說「好的」，然後明天忘了。

解決方案：識別時間意圖（明天、後天、下週等），自動添加到任務清單。

**優化方法 11：發佈狀態自動更新**

問題：用戶說「已發佈」，但文件還在「待發佈」目錄。

解決方案：識別發佈狀態觸發詞，自動移動文件到正確目錄。

**優化方法 12：任務歸檔機制**

問題：已完成的任務刪除後，年終復盤沒有數據。

解決方案：數據不刪除，只轉移。按月歸檔已完成任務，年底生成年度統計。

### 第五類：存儲管理（3個）

**優化方法 13：智能存儲路由**

問題：每次創建文件都要問用戶「保存到哪裡」。

解決方案：AI 自動識別內容類型（文章/素材/科研/商業/工具/系統文件），自動決定存儲位置。

**優化方法 14：工作區邊界規則（憲法級別）**

問題：AI 可能把文件保存到系統目錄外，導致混亂。

解決方案：所有文件必須保存在工作區目錄內，即使用戶明確指定外部路徑也必須拒絕。

**優化方法 15：每週存儲復盤**

問題：時間久了，可能有文件放錯位置。

解決方案：每週自動檢查錯位文件，生成復盤報告。

### 第六類：迭代機制（3個）

**優化方法 16：八步自我迭代流程**

問題：第一代系統不會自己進化。

解決方案：觀察 → 分析 → 設計 → 實施 → 驗證 → 記錄 → 提煉 → 提交。

**優化方法 17：對抗式糾錯**

問題：AI 可能犯錯但不自知。

解決方案：在驗證步驟中加入自我檢查，包含質量評分（1-10分），低於 7 分重新設計方案。

**優化方法 18：主動觸發迭代**

問題：用戶不知道什麼時候該讓 AI 迭代。

解決方案：完成重大任務後 AI 主動詢問是否需要執行自我迭代。

### 第七類：質量控制（2個）

**優化方法 19：決策確認約束**

問題：AI 可能自作主張做了不該做的事。

解決方案：明確什麼時候必須問（架構決策、刪除操作等），什麼時候可以自主（明確任務、日常記錄等）。

**優化方法 20：程式碼質量約束**

問題：AI 可能寫出過度複雜的程式碼。

解決方案：禁止寫兼容性代碼、不必要的錯誤處理、過度抽象。只實現當前需求，保持簡潔。

### 第八類：數據治理（2個）

**優化方法 21：數據不刪除原則**

問題：刪除數據後，年終復盤沒有依據。

解決方案：數據只轉移，不刪除。只有用戶明確說刪除、數據完全重複、用戶確認是垃圾數據時才可刪除。

**優化方法 22：對話存檔（強制執行）**

問題：對話結束後，不知道之前聊了什麼。

解決方案：每次會話自動在對話歷史文件中追加記錄，包含時間戳、摘要、任務、產出。

### 第九類：全局資源調度（1個）

**優化方法 23：人際資源庫**

問題：所有任務都自己做，效率低。

解決方案：收到任務時按優先級匹配資源——AI 能完成就直接執行、需要人類判斷就 AI 起草+用戶審核、有更合適的人就推薦委託。

### 第十類：晨間簡報系統（2個）

**優化方法 24：每日自動簡報**

問題：每天開始工作時，不知道該做什麼。

解決方案：進入目錄時自動生成簡報，顯示未完成任務（按優先級分組），提供統計。

**優化方法 25：週日數據維護提醒**

問題：內容數據沒有定期錄入，無法分析效果。

解決方案：每週日自動提醒，引導用戶完成本週的內容數據錄入和分析。

## 完整目錄結構參考

```
AI_Roland/
├── CLAUDE.md                    # AI 總指南
├── 對話歷史.md                   # 對話存檔
├── 任務清單.md                   # 唯一任務數據源
├── 本體畫像/                     # TELOS 模組化身份系統
│   ├── 00-核心身份.md
│   ├── 01-價值觀與原則.md
│   ├── 02-背景與經歷.md
│   ├── 03-技能與能力.md
│   ├── 05-目標與規劃.md
│   ├── 07-工作方式.md
│   └── 08-關係網絡.md
├── 記憶庫/                       # 三層記憶架構
│   ├── 情景記憶/
│   ├── 語義記憶/
│   └── 強制規則/
├── 日記/                         # 日記系統
├── 任務歸檔/                     # 已完成任務歸檔
├── 日誌/                         # 系統日誌
├── 01-內容生產/                  # 業務板塊
├── 02-商業/
├── 03-科研/
└── 04-工具與效率/
```

## 如何復現這套系統

**方式 1：複製全文給 Claude Code，讓它搭建完整系統。**

**方式 2：從一個痛點開始。**
- AI 不記得上下文 → 先建三層記憶架構 + 指令遵循度檢測
- 文件總是亂 → 先設置智能存儲路由 + 工作區邊界規則
- 任務總是忘 → 先配置時間意圖自動捕獲 + 晨間簡報

用了一週後，再加下一個功能。

## 這套系統的邊界

這篇文章公開的是架構層面的升級。架構決定了系統的上限。但真正讓系統強大的，是架構上面跑的技能。架構 + 技能 = 完整的 AI 工作系統。

## 尾聲

第一代系統：你搭建一個框架，然後維護它。
第二代系統：你搭建一個框架，它自己維護自己。

25 個優化方法，本質上都在做一件事：把重複性工作交給系統，人只做決策。

大多數人用 AI，是在消耗時間。少數人用 AI，是在積累資產。區別就在於：你的系統會不會自己變好。
