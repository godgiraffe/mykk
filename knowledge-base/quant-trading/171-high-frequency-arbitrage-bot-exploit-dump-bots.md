# 80行高頻套利策略剝削無腦出貨機器人

> **來源**: [@0xKaKa03](https://x.com/0xKaKa03/status/1946596473489215782) | [原文連結](https://www.fmz.com/digest-topic/10328)
>
> **日期**: Sat Jul 19 15:42:19 +0000 2025
>
> **標籤**: `高頻交易` `市場微觀結構` `套利` `做市策略`

---

> **來源**: [@0xKaKa03 (Sliipy⚡)](https://x.com/0xKaKa03)  
> **日期**: 2023-12-24  
> **標籤**: `高頻交易` `套利策略` `市場微觀結構` `做市策略`

---

## 策略概述

這是一個針對幣安現貨市場的低風險高頻套利策略。當發現大戶使用無腦冰山委託機器人持續出貨時，利用其機械化操作造成的短期定價錯誤進行套利。策略僅需 80 行代碼即可實現。

## 利潤來源

套利機會源自三個關鍵因素：

1. **大戶不專業操作**：由於流動性不足，大戶的大量代幣無法一次性賣出，選擇使用定時腳本出貨。如果腳本考慮買單深度就不會產生那麼多「針」可接
2. **市場活躍度**：僅有大戶出貨還不足以構成套利條件，需要市場有一定熱度且持續有新買單為接針後的套利者接盤
3. **長尾策略特性**：這類機會可能時而出現而不容易被捕獲，雖然容量有限但可能只有你一個人獨享。有效的監控和對價格的敏感性缺一不可

## 實際案例：STORJ 套利

### 機會觀察

在幣安 STORJ 交易對發現異常行情：

- **交易特徵**：交易量大且頻率非常快
- **K 線表現**：每分鐘交易量一致，分鐘線上出現長長的下影線
- **1 秒級觀察**：每隔 5-7 秒就有人市價賣出 1-2 萬個 STORJ，不計成本直接在 K 線上砸坑，價格短期內會恢復

這顯然是冰山委託機器人造成的操作，持續時間非常長，總量估計達到千萬美元級別。很多時候造成的滑點達到千分之一，意味著僅交易滑點執行者就虧了上萬美元。

### 策略思路

既然每隔幾秒都會市價賣出，只需在買單簿中找到 1 萬的深度，把單子掛在前面：

1. 做市機器人在冰山賣出時有很高概率正好接到
2. 此時交易非常活躍，瞬間的價格下滑引發一些買單
3. 同樣掛賣單順勢拋出
4. 如此反復操作

成交頻率非常高，即使每次收益率不大總收益也相當可觀。**前提是有低手續費賬號**，如果買賣手續費都是千分之一，這個空間根本不夠交手續費。

### 策略表現

- **收益水平**：剛開始每小時大概能賺 100-200U
- **風險特性**：無風險、低成本
- **後期變化**：瘋狂拋售的機器人已經把每次的量改為 5000 左右，過了最佳套利時期

### 反思：冰山委託的優化

從這個案例反過來看，冰山委託其實也有很多技巧。如果會寫策略，在 FMZ 上花十幾分鐘就能寫出具有以下特點的冰山委託策略：

- 觀察買單訂單深度決定下單大小和價格
- 觀察主動買單的大小調整掛單大小並佔據盤口

這樣可以輕鬆節約幾萬美元。

## 策略實現

策略代碼非常簡單，只有 80 行，適合初學者。一些參數如下單精度之類的寫死在程序裡，可以自己修改。

### 核心函數

**1. 取消掛單**
```javascript
function CancelPendingOrders() {
    var orders = _C(exchange.GetOrders)
    for (var j = 0; j < orders.length; j++) {
        exchange.CancelOrder(orders[j].Id, orders[j])
    }
}
```

**2. 獲取掛單價格**
```javascript
function GetPrice(Type, Depth) {
    var sumAmount = 0
    var checkAmount = Type == "Buy" ? CheckBuyAmount : CheckSellAmount
    var deep = Type == "Buy" ? Depth.Bids : Depth.Asks
    for(var i = 0; i < Math.min(20, deep.length); i++) {
        if(Type == "Buy" && deep[i].Price == lastBuyPrice && buyId){
            sumAmount += deep[i].Amount - amountBuy //減去自己的掛單
        }else if(Type == "Sell" && deep[i].Price == lastSellPrice && sellId){
            sumAmount += deep[i].Amount - amountSell
        }else{
            sumAmount += deep[i].Amount
        }
        if(sumAmount >= checkAmount){
            return deep[i].Price
        }
    }
    return deep[19].Price
}
```

**3. 主交易邏輯**
```javascript
function OnTick() {
    var depth = _C(exchange.GetDepth)
    var buyPrice = _N(Math.min(GetPrice("Buy", depth) + 0.0001, depth.Asks[0].Price-0.0001), 4) //保證在盤口
    var sellPrice = _N(Math.max(GetPrice("Sell", depth) - 0.0001, depth.Bids[0].Price+0.0001), 4)
    
    if ((sellPrice - buyPrice) < DiffPrice) {
        buyPrice = 0
    }
    
    // 撤銷舊單
    if(sellPrice != lastSellPrice && sellId){
        exchange.CancelOrder(sellId)
        sellId = 0
        lastSellPrice = 0
    }
    if(buyPrice != lastBuyPrice && buyId){
        exchange.CancelOrder(buyId)
        buyId = 0
        lastBuyPrice = 0
    }
    
    // 記錄收益
    var acc = _C(exchange.GetAccount)
    if(account.Stocks+account.FrozenStocks != acc.Stocks+acc.FrozenStocks){
        LogProfit((acc.Stocks+acc.FrozenStocks)*depth.Bids[0].Price+acc.Balance+acc.FrozenBalance - 2000)
    }
    
    // 計算可用量
    account = acc
    amountBuy = _N(Math.min(account.Balance / buyPrice - 0.1, Amount), 0)
    amountSell = _N(account.Stocks, 0)
    
    // 掛單
    if (sellPrice > 0 && amountSell > 40 && sellId == 0) {
        sellId = exchange.Sell(_N(sellPrice,4), amountSell)
        lastSellPrice = sellPrice
    }
    if (buyPrice>0 && amountBuy > 40 && buyId == 0) {
        buyId = exchange.Buy(_N(buyPrice,4), amountBuy)
        lastBuyPrice = buyPrice
    }
    
    Sleep(Interval)
}
```

**4. 主函數**
```javascript
var account = {Stocks:0, FrozenStocks:0, Balance:0, FrozenBalance:0}
var buyId = 0
var sellId = 0
var lastBuyPrice = 0
var lastSellPrice = 0
var amountSell = 0
var amountBuy = 0

function main() {
    CancelPendingOrders()
    while (true) {
        OnTick()
    }
}

function onexit(){
    CancelPendingOrders()
}
```

## 參數設置

策略需要以下參數（具體數值根據交易對調整）：

- `CheckBuyAmount`：檢查買單深度閾值
- `CheckSellAmount`：檢查賣單深度閾值
- `DiffPrice`：最小價差要求
- `Amount`：每次交易數量
- `Interval`：輪詢間隔（毫秒）

## 使用建議

1. **保存備用**：建議保存該策略，萬一哪個交易所交易對又出現抽風的交易者，隨時向他們收點利息
2. **手續費要求**：必須有低手續費賬號（VIP 等級），否則無法盈利
3. **參數優化**：根據具體交易對調整下單精度、深度檢查閾值等參數
4. **監控重要**：需要持續監控市場，發現類似機會及時部署
